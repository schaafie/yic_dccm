{"version":3,"file":"code-editor.umd.js","sources":["code-editor.umd.js"],"sourcesContent":["/**\n * Copyright 2019 The Pennsylvania State University\n * @license Apache-2.0, see License.md for full text.\n */\nimport { html, PolymerElement } from \"@polymer/polymer/polymer-element.js\";\nimport { FlattenedNodesObserver } from \"@polymer/polymer/lib/utils/flattened-nodes-observer.js\";\nimport { dom } from \"@polymer/polymer/lib/legacy/polymer.dom.js\";\nimport { afterNextRender } from \"@polymer/polymer/lib/utils/render-status.js\";\nimport { SchemaBehaviors } from \"@lrnwebcomponents/schema-behaviors/schema-behaviors.js\";\n/**\n * `code-editor`\n * `Wrapper on top of a code editor`\n *\n * @demo demo/index.html\n * @microcopy - the mental model for this element\n * - monaco is the VS code editor\n */\nclass CodeEditor extends SchemaBehaviors(PolymerElement) {\n  constructor() {\n    super();\n    this.__libPath =\n      decodeURIComponent(import.meta.url) + \"/../../../monaco-editor/min/vs\";\n    import(\"@lrnwebcomponents/code-editor/lib/monaco-element/monaco-element.js\");\n    import(\"@lrnwebcomponents/code-editor/lib/code-pen-button.js\");\n    this.addEventListener(\"monaco-element-ready\", this.editorReady.bind(this));\n  }\n  static get template() {\n    return html`\n      <style>\n        :host {\n          display: block;\n          padding: 16px;\n          font-family: unset;\n        }\n        :host([hidden]) {\n          display: none !important;\n        }\n        .code-pen-container:not([hidden]) {\n          width: 100%;\n          display: flex;\n          background-color: var(--code-pen-button-color, #222222);\n          color: white;\n          height: 40px;\n          justify-content: flex-end;\n          align-items: center;\n        }\n        .code-pen-container span {\n          display: inline-flex;\n          line-height: 16px;\n          font-size: 16px;\n          padding: 12px;\n        }\n        code-pen-button {\n          float: right;\n          height: 40px;\n        }\n        label {\n          color: var(--code-editor-label-color, #888);\n          transition: all 0.5s;\n          @apply --code-editor-label;\n        }\n\n        :host([focused]) label {\n          color: var(\n            --code-editor-float-label-active-color,\n            var(--code-editor-label-color, #000)\n          );\n          @apply --code-editor-focus-label;\n        }\n\n        #codeeditor {\n          height: 100%;\n          display: flex;\n          @apply --code-editor-code;\n        }\n\n        :host([focused]) #codeeditor {\n          @apply --code-editor-focus-code;\n        }\n      </style>\n      <label for=\"codeeditor\" hidden$=\"[[!title]]\">[[title]]</label>\n      <monaco-element\n        id=\"codeeditor\"\n        autofocus$=\"[[autofocus]]\"\n        hide-line-numbers$=\"[[hideLineNumbers]]\"\n        lib-path=\"[[__libPath]]\"\n        language=\"[[language]]\"\n        theme=\"[[theme]]\"\n        on-value-changed=\"_editorDataChanged\"\n        font-size$=\"[[fontSize]]\"\n        read-only$=\"[[readOnly]]\"\n        on-code-editor-focus=\"_handleFocus\"\n        on-code-editor-blur=\"_handleBlur\"\n      >\n      </monaco-element>\n      <div class=\"code-pen-container\" hidden$=\"[[!showCodePen]]\">\n        <span>Check it out on code pen: </span\n        ><code-pen-button data=\"[[codePenData]]\"></code-pen-button>\n      </div>\n    `;\n  }\n\n  static get tag() {\n    return \"code-editor\";\n  }\n\n  static get properties() {\n    let props = {\n      /**\n       * Title\n       */\n      title: {\n        type: String\n      },\n\n      /**\n       * Show codePen button to fork it to there to run\n       */\n      showCodePen: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * Readonly setting for the editor\n       */\n      readOnly: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * Code pen data, computed based on the HTML editor\n       */\n      codePenData: {\n        type: Object,\n        computed: \"_computeCodePenData(title, value)\"\n      },\n      /**\n       * contents of the editor\n       */\n      editorValue: {\n        type: String,\n        observer: \"_editorValueChanged\"\n      },\n      /**\n       * value of the editor after the fact\n       */\n      value: {\n        type: String,\n        notify: true\n      },\n      /**\n       * Theme for the Ace editor.\n       */\n      theme: {\n        type: String,\n        value: \"vs-dark\"\n      },\n      /**\n       * Mode / language for editor\n       */\n      mode: {\n        type: String,\n        observer: \"_modeChanged\"\n      },\n      /**\n       * Language to present color coding for\n       */\n      language: {\n        type: String,\n        value: \"javascript\"\n      },\n      /**\n       * font size for the editor\n       */\n      fontSize: {\n        type: Number,\n        value: 16\n      },\n      /**\n       * automatically set focus on the editor\n       */\n      autofocus: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      },\n      /**\n       * hide the line numbers\n       */\n      hideLineNumbers: {\n        type: Boolean,\n        value: false\n      },\n      /**\n       * does the monaco-editor have focus\n       */\n      focused: {\n        type: Boolean,\n        value: false,\n        reflectToAttribute: true\n      }\n    };\n    if (super.properties) {\n      props = Object.assign(props, super.properties);\n    }\n    return props;\n  }\n\n  /**\n   * Update the post data whenever the editor has been updated\n   */\n  _computeCodePenData(title, editorValue) {\n    return {\n      title: title,\n      html: editorValue\n    };\n  }\n  /**\n   * sets focused attribute when monaco-elements's focus event fires\n   * @param {event} e the monaco-elements's focus event\n   */\n  _handleFocus(e) {\n    this.focused = true;\n  }\n  /**\n   * unsets focused attribute when monaco-elements's blur event fires\n   * @param {event} e the monaco-elements's blur event\n   */\n  _handleBlur(e) {\n    this.focused = false;\n  }\n  /**\n   * LEGACY: pass down mode to language if that api is used\n   */\n  _modeChanged(newValue) {\n    this.language = this.mode;\n  }\n\n  /**\n   * Notice code editor changes and reflect them into this element\n   */\n  _editorDataChanged(e) {\n    // value coming up off of thiss\n    this.value = e.detail;\n  }\n\n  /**\n   * Calculate what's in slot currently and then inject it into the editor.\n   */\n  updateEditorValue(node) {\n    if (node) {\n      var content = \"\";\n      var children = node;\n      if (node.tagName !== \"TEMPLATE\") {\n        console.warn(\n          \"code-editor works best with a template tag provided in light dom\"\n        );\n        children = dom(this).getEffectiveChildNodes();\n        if (children.length > 0) {\n          // loop through everything found in the slotted area and put it back in\n          for (var j = 0, len2 = children.length; j < len2; j++) {\n            if (typeof children[j].tagName !== typeof undefined) {\n              content += children[j].outerHTML;\n            } else {\n              content += children[j].textContent;\n            }\n          }\n        }\n      } else {\n        content = children.innerHTML;\n      }\n      if (content) {\n        this.shadowRoot.querySelector(\"#codeeditor\").value = content.trim();\n      }\n    }\n  }\n  _editorValueChanged(newValue) {\n    if (newValue) {\n      this.shadowRoot.querySelector(\"#codeeditor\").value = newValue;\n    }\n  }\n  /**\n   * Ensure fields don't pass through to HAX if in that context\n   */\n  preProcessHaxNodeToContent(clone) {\n    clone.editorValue = null;\n    clone.codePenData = null;\n    clone.value = null;\n    clone.removeAttribute(\"value\");\n    clone.removeAttribute(\"code-pen-data\");\n    return clone;\n  }\n  /**\n   * attached life cycle\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    let root = this;\n    afterNextRender(this, function() {\n      // mutation observer that ensures state of hax applied correctly\n      this._observer = new FlattenedNodesObserver(this, info => {\n        // if we've got new nodes, we have to react to that\n        if (info.addedNodes.length > 0) {\n          info.addedNodes.map(node => {\n            if (node.tagName) {\n              this.updateEditorValue(node);\n            }\n          });\n        }\n        // if we dropped nodes via the UI (delete event basically)\n        if (info.removedNodes.length > 0) {\n          // handle removing items... not sure we need to do anything here\n          info.removedNodes.map(node => {\n            if (node.tagName) {\n              this.updateEditorValue(node);\n            }\n          });\n        }\n      });\n    });\n  }\n  disconnectedCallback() {\n    this.removeEventListener(\n      \"monaco-element-ready\",\n      this.editorReady.bind(this)\n    );\n    if (this._observer) {\n      this._observer.disconnect();\n      this._observer = null;\n    }\n    super.disconnectedCallback();\n  }\n  editorReady(e) {\n    if (this.editorValue) {\n      this.shadowRoot.querySelector(\"#codeeditor\").value = this.editorValue;\n    }\n  }\n}\nwindow.customElements.define(CodeEditor.tag, CodeEditor);\nexport { CodeEditor };\n"],"names":["CodeEditor","__libPath","decodeURIComponent","addEventListener","_this","editorReady","bind","SchemaBehaviors","PolymerElement","html","props","title","type","String","showCodePen","Boolean","value","reflectToAttribute","readOnly","codePenData","Object","computed","editorValue","observer","notify","theme","mode","language","fontSize","Number","autofocus","hideLineNumbers","focused","assign","e","newValue","this","detail","node","content","children","tagName","console","warn","dom","getEffectiveChildNodes","length","j","len2","_typeof","outerHTML","textContent","innerHTML","shadowRoot","querySelector","trim","clone","removeAttribute","afterNextRender","_observer","FlattenedNodesObserver","info","addedNodes","map","_this2","updateEditorValue","removedNodes","removeEventListener","disconnect","window","customElements","define","tag"],"mappings":"wjIAiBMA,kOAGGC,UACHC,mMAAsC,wCACjC,6EACA,0DACFC,iBAAiB,uBAAwBC,EAAKC,YAAYC,oQAP1CC,kBAAgBC,gEAU9BC,8CA4EA,qDAIHC,EAAQ,CAIVC,MAAO,CACLC,KAAMC,QAMRC,YAAa,CACXF,KAAMG,QACNC,OAAO,EACPC,oBAAoB,GAKtBC,SAAU,CACRN,KAAMG,QACNC,OAAO,EACPC,oBAAoB,GAKtBE,YAAa,CACXP,KAAMQ,OACNC,SAAU,qCAKZC,YAAa,CACXV,KAAMC,OACNU,SAAU,uBAKZP,MAAO,CACLJ,KAAMC,OACNW,QAAQ,GAKVC,MAAO,CACLb,KAAMC,OACNG,MAAO,WAKTU,KAAM,CACJd,KAAMC,OACNU,SAAU,gBAKZI,SAAU,CACRf,KAAMC,OACNG,MAAO,cAKTY,SAAU,CACRhB,KAAMiB,OACNb,MAAO,IAKTc,UAAW,CACTlB,KAAMG,QACNC,OAAO,EACPC,oBAAoB,GAKtBc,gBAAiB,CACfnB,KAAMG,QACNC,OAAO,GAKTgB,QAAS,CACPpB,KAAMG,QACNC,OAAO,EACPC,oBAAoB,uCAItBP,EAAQU,OAAOa,OAAOvB,8BAEjBA,mDAMWC,EAAOW,SAClB,CACLX,MAAOA,EACPF,KAAMa,wCAOGY,QACNF,SAAU,sCAMLE,QACLF,SAAU,uCAKJG,QACNR,SAAWS,KAAKV,gDAMJQ,QAEZlB,MAAQkB,EAAEG,iDAMCC,MACZA,EAAM,KACJC,EAAU,GACVC,EAAWF,KACM,aAAjBA,EAAKG,YACPC,QAAQC,KACN,qEAEFH,EAAWI,MAAIR,MAAMS,0BACRC,OAAS,MAEf,IAAIC,EAAI,EAAGC,EAAOR,EAASM,OAAQC,EAAIC,EAAMD,kBAC5CE,EAAOT,EAASO,GAAGN,SACrBF,GAAWC,EAASO,GAAGG,UAEvBX,GAAWC,EAASO,GAAGI,iBAK7BZ,EAAUC,EAASY,UAEjBb,SACGc,WAAWC,cAAc,eAAetC,MAAQuB,EAAQgB,qDAI/CpB,GACdA,SACGkB,WAAWC,cAAc,eAAetC,MAAQmB,sDAM9BqB,UACzBA,EAAMlC,YAAc,KACpBkC,EAAMrC,YAAc,KACpBqC,EAAMxC,MAAQ,KACdwC,EAAMC,gBAAgB,SACtBD,EAAMC,gBAAgB,iBACfD,oGAQPE,kBAAgBtB,KAAM,2BAEfuB,UAAY,IAAIC,yBAAuBxB,KAAM,SAAAyB,GAE5CA,EAAKC,WAAWhB,OAAS,GAC3Be,EAAKC,WAAWC,IAAI,SAAAzB,GACdA,EAAKG,SACPuB,EAAKC,kBAAkB3B,KAKzBuB,EAAKK,aAAapB,OAAS,GAE7Be,EAAKK,aAAaH,IAAI,SAAAzB,GAChBA,EAAKG,SACPuB,EAAKC,kBAAkB3B,6DAQ5B6B,oBACH,uBACA/B,KAAK/B,YAAYC,KAAK8B,OAEpBA,KAAKuB,iBACFA,UAAUS,kBACVT,UAAY,mGAITzB,GACNE,KAAKd,mBACF+B,WAAWC,cAAc,eAAetC,MAAQoB,KAAKd,kDAIhE+C,OAAOC,eAAeC,OAAOvE,EAAWwE,IAAKxE"}